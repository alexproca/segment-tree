require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({"SegmentTree":[function(require,module,exports){
module.exports=require('8U2X6G');
},{}],"8U2X6G":[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var exports;



  exports = module.exports = require('./segment-tree').SegmentTree;

}).call(this);

},{"./segment-tree":1}],1:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var BoundingBox, DEFAULTS, SegmentTree, Utils;



  BoundingBox = require('./bounding-box').BoundingBox;

  Utils = require('./utils').Utils;

  /*
  
  a segment is a pair of points, where each point is an N-dimensional
  array, and some object you want associated with that segment
  
  Example:
    new SegmentTree {
      insertions: [
        {object: o1, segment: [[1, 2], [3,  10]}
        {object: o2, segment: [[3, 5], [3,  10]}
      ]
      dimensions:   2
      min_to_split: 8
      split_gain:   0.40 #  when a tree subdivides, 
                         #  x% go solely into one subtree, 
                         #  y% go solely into another,
                         #  Only subdivide if x and y are both greater than split_gain
    }
  */


  DEFAULTS = {
    SPLIT_GAIN: 0.2,
    MIN_TO_SPLIT: 16
  };

  SegmentTree = (function() {
    function SegmentTree(_arg) {
      var dimensions, id, insertion, insertions, min_to_split, split_gain, _i, _len;
      insertions = _arg.insertions, dimensions = _arg.dimensions, split_gain = _arg.split_gain, min_to_split = _arg.min_to_split;
      this.split_gain = split_gain || DEFAULTS.SPLIT_GAIN;
      this.min_to_split = min_to_split || DEFAULTS.MIN_TO_SPLIT;
      this.dimensions = dimensions;
      this.tree = this._new_tree();
      this.by_id = {};
      this.id_count = 0;
      this.num_trees = 1;
      if (insertions != null ? insertions.length : void 0) {
        for (_i = 0, _len = insertions.length; _i < _len; _i++) {
          insertion = insertions[_i];
          id = this._record_and_get_id(insertion);
          this._add(id, insertion.segment, this.tree, 0);
        }
        this._perform_splits(this.tree, 0);
      }
    }

    SegmentTree.prototype.add = function(_arg) {
      var id, object, segment;
      object = _arg.object, segment = _arg.segment;
      id = this._record_and_get_id({
        object: object,
        segment: segment
      });
      this._add(id, segment, this.tree, 0);
      return id;
    };

    SegmentTree.prototype.nearest_segment = function(tuple) {
      return this._find_nearest_segment(tuple, this.tree);
    };

    SegmentTree.prototype.nearest_vertex = function(tuple) {
      return this._find_nearest_vertex(tuple, this.tree);
    };

    SegmentTree.prototype.vertices_inside_ball = function(tuple, radius) {
      var res;
      res = [];
      this._find_vertices_inside_ball(tuple, this.tree, radius, res);
      return res;
    };

    SegmentTree.prototype.summarize = function() {
      return {
        num_trees: this.num_trees,
        num_objs: this.get_all_objs().length
      };
    };

    SegmentTree.prototype.get_all_objs = function() {
      var k, v, _ref, _results;
      _ref = this.by_id;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(v.o);
      }
      return _results;
    };

    SegmentTree.prototype._record_and_get_id = function(insertion) {
      var id;
      id = this.id_count++;
      this.by_id[id] = {
        o: insertion.object,
        segment: insertion.segment
      };
      return id;
    };

    SegmentTree.prototype._new_tree = function() {
      return {
        items: [],
        left: null,
        right: null,
        axis: null,
        divider: null,
        bounds: null
      };
    };

    SegmentTree.prototype._perform_splits = function(tree, depth) {
      var _ref;
      if ((_ref = tree.items) != null ? _ref.length : void 0) {
        this._maybe_split(tree, depth);
      }
      if (tree.left != null) {
        this._perform_splits(tree.left, depth + 1);
        return this._perform_splits(tree.right, depth + 1);
      }
    };

    SegmentTree.prototype._add = function(id, segment, tree, depth) {
      if (tree.bounds != null) {
        tree.bounds.contain(segment[0]);
        tree.bounds.contain(segment[1]);
      } else {
        tree.bounds = new BoundingBox(segment[0], segment[1]);
      }
      if (tree.axis != null) {
        if (this._is_on_left(segment, tree.axis, tree.divider)) {
          this._add(id, segment, tree.left, depth + 1);
        }
        if (this._is_on_right(segment, tree.axis, tree.divider)) {
          return this._add(id, segment, tree.right, depth + 1);
        }
      } else {
        return tree.items.push({
          id: id,
          segment: segment
        });
      }
    };

    SegmentTree.prototype._find_vertices_inside_ball = function(tuple, tree, radius, res) {
      var dsq, i, item, left_info, right_info, vertex_num, _i, _len, _ref, _ref1, _results;
      if ((_ref = tree.items) != null ? _ref.length : void 0) {
        _ref1 = tree.items;
        _results = [];
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          item = _ref1[i];
          dsq = Utils.dist_sq(tuple, item.segment[0]);
          _results.push((function() {
            var _j, _len1, _ref2, _results1;
            _ref2 = [0, 1];
            _results1 = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              vertex_num = _ref2[_j];
              if (dsq < radius * radius) {
                _results1.push(res.push({
                  distance: Math.sqrt(dsq),
                  vertex: item.segment[vertex_num],
                  vertex_num: vertex_num,
                  object: this.by_id[item.id].o
                }));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      } else {
        left_info = tree.left.bounds.distance_from_vec(tuple);
        right_info = tree.right.bounds.distance_from_vec(tuple);
        if (left_info.distance <= radius) {
          this._find_vertices_inside_ball(tuple, tree.left, radius, res);
        }
        if (right_info.distance <= radius) {
          return this._find_vertices_inside_ball(tuple, tree.right, radius, res);
        }
      }
    };

    SegmentTree.prototype._find_nearest_vertex = function(tuple, tree) {
      var closest_item, closest_item_dsq, closest_vertex, dsq, i, item, left_best, left_info, right_best, right_info, vertex_num, _i, _len, _ref;
      if (tree.axis != null) {
        left_info = tree.left.bounds.distance_from_vec(tuple);
        right_info = tree.right.bounds.distance_from_vec(tuple);
        if (left_info.distance < right_info.distance) {
          left_best = this._find_nearest_vertex(tuple, tree.left);
          if (left_best.distance < right_info.distance) {
            return left_best;
          }
          right_best = this._find_nearest_vertex(tuple, tree.right);
        } else {
          right_best = this._find_nearest_vertex(tuple, tree.right);
          if (right_best.distance < left_info.distance) {
            return right_best;
          }
          left_best = this._find_nearest_vertex(tuple, tree.left);
        }
        if (left_best.distance < right_best.distance) {
          return left_best;
        } else {
          return right_best;
        }
      } else {
        if (!tree.items.length) {
          return {
            distance: Infinity,
            vertex: null,
            object: null,
            vertex_num: null
          };
        } else {
          closest_item = null;
          closest_vertex = null;
          closest_item_dsq = null;
          _ref = tree.items;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            item = _ref[i];
            dsq = Utils.dist_sq(tuple, item.segment[0]);
            if ((!i) || dsq < closest_item_dsq) {
              closest_item = item;
              closest_vertex = item.segment[0];
              closest_item_dsq = dsq;
              vertex_num = 0;
            }
            dsq = Utils.dist_sq(tuple, item.segment[1]);
            if (dsq < closest_item_dsq) {
              closest_item = item;
              closest_vertex = item.segment[1];
              closest_item_dsq = dsq;
              vertex_num = 1;
            }
          }
          return {
            vertex: closest_vertex,
            distance: Math.sqrt(closest_item_dsq),
            object: this.by_id[closest_item.id].o,
            vertex_num: vertex_num
          };
        }
      }
    };

    SegmentTree.prototype._find_nearest_segment = function(tuple, tree) {
      var closest_item, closest_item_info, i, info, item, left_best, left_info, right_best, right_info, _i, _len, _ref;
      if (tree.axis != null) {
        left_info = tree.left.bounds.distance_from_vec(tuple);
        right_info = tree.right.bounds.distance_from_vec(tuple);
        if (left_info.distance < right_info.distance) {
          left_best = this._find_nearest_segment(tuple, tree.left);
          if (left_best.distance < right_info.distance) {
            return left_best;
          }
          right_best = this._find_nearest_segment(tuple, tree.right);
        } else {
          right_best = this._find_nearest_segment(tuple, tree.right);
          if (right_best.distance < left_info.distance) {
            return right_best;
          }
          left_best = this._find_nearest_segment(tuple, tree.left);
        }
        if (left_best.distance < right_best.distance) {
          return left_best;
        } else {
          return right_best;
        }
      } else {
        if (!tree.items.length) {
          return {
            distance: Infinity,
            point: null,
            segment: null,
            object: null,
            position_on_segment: null
          };
        } else {
          closest_item = null;
          closest_item_info = null;
          _ref = tree.items;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            item = _ref[i];
            info = Utils.point_segment_dist(tuple, item.segment);
            if ((!i) || info.dist < closest_item_info.dist) {
              closest_item = item;
              closest_item_info = info;
            }
          }
          return {
            distance: closest_item_info.dist,
            point: closest_item_info.point,
            position_on_segment: closest_item_info.position_on_segment,
            segment: closest_item.segment,
            object: this.by_id[closest_item.id].o
          };
        }
      }
    };

    SegmentTree.prototype._maybe_split = function(tree, depth) {
      var axis, ni, sc, split_candidates;
      ni = tree.items.length;
      if (ni < this.min_to_split) {
        return;
      }
      split_candidates = (function() {
        var _i, _ref, _results;
        _results = [];
        for (axis = _i = 0, _ref = this.dimensions; 0 <= _ref ? _i < _ref : _i > _ref; axis = 0 <= _ref ? ++_i : --_i) {
          _results.push(this._get_split_candidate(tree, axis));
        }
        return _results;
      }).call(this);
      split_candidates.sort(function(a, b) {
        return b.split_gain - a.split_gain;
      });
      if ((sc = split_candidates[0]).split_gain >= this.split_gain) {
        return this._split(tree, sc.axis, sc.divider, depth);
      }
    };

    SegmentTree.prototype._is_on_left = function(segment, axis, divider) {
      var n1, n2;
      n1 = segment[0][axis];
      n2 = segment[1][axis];
      return (n1 <= divider) || (n2 <= divider);
    };

    SegmentTree.prototype._is_on_right = function(segment, axis, divider) {
      var n1, n2;
      n1 = segment[0][axis];
      n2 = segment[1][axis];
      return (n1 > divider) || (n2 > divider);
    };

    SegmentTree.prototype._split = function(tree, axis, divider, depth) {
      var i, to_move, _i, _len, _results;
      tree.left = this._new_tree();
      tree.right = this._new_tree();
      tree.axis = axis;
      tree.divider = divider;
      to_move = tree.items;
      tree.items = null;
      this.num_trees++;
      _results = [];
      for (_i = 0, _len = to_move.length; _i < _len; _i++) {
        i = to_move[_i];
        _results.push(this._add(i.id, i.segment, tree, depth + 1));
      }
      return _results;
    };

    SegmentTree.prototype._get_split_candidate = function(tree, axis) {
      var res;
      res = {
        divider: (tree.bounds.ll[axis] + tree.bounds.ur[axis]) / 2,
        split_gain: null,
        axis: axis
      };
      /*
      left_points  = (i.segment[0][axis] for i in tree.items)
      right_points = (i.segment[1][axis] for i in tree.items)
      points = []
      points.push p for p in left_points
      points.push p for p in right_points
      res.divider     = Utils.median points
      */

      res.split_gain = this._calc_split_gain(tree.items, axis, res.divider);
      return res;
    };

    SegmentTree.prototype._calc_split_gain = function(items, axis, divider) {
      var duplicates, item, left_count, lsc, right_count, rsc, s, _i, _len;
      left_count = 0;
      right_count = 0;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        s = item.segment;
        if (this._is_on_left(s, axis, divider)) {
          left_count++;
        }
        if (this._is_on_right(s, axis, divider)) {
          right_count++;
        }
      }
      duplicates = left_count + right_count - items.length;
      lsc = left_count - duplicates;
      rsc = right_count - duplicates;
      return Math.min(lsc / items.length, rsc / items.length);
    };

    return SegmentTree;

  })();

  exports.SegmentTree = SegmentTree;

}).call(this);

},{"./bounding-box":2,"./utils":3}],2:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var BoundingBox;



  BoundingBox = (function() {
    function BoundingBox(lower_left, upper_right) {
      var n;
      this.ll = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lower_left.length; _i < _len; _i++) {
          n = lower_left[_i];
          _results.push(n);
        }
        return _results;
      })();
      this.ur = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = upper_right.length; _i < _len; _i++) {
          n = upper_right[_i];
          _results.push(n);
        }
        return _results;
      })();
    }

    BoundingBox.prototype.contain = function(vec) {
      var dim, n, _i, _len, _results;
      _results = [];
      for (dim = _i = 0, _len = vec.length; _i < _len; dim = ++_i) {
        n = vec[dim];
        if (n < this.ll[dim]) {
          this.ll[dim] = n;
        }
        if (n > this.ur[dim]) {
          _results.push(this.ur[dim] = n);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    BoundingBox.prototype.distance_from_vec = function(vec) {
      var dim, distance, dsq, is_contained, n, nearest, v, _i, _len;
      nearest = [];
      dsq = 0;
      is_contained = true;
      for (dim = _i = 0, _len = vec.length; _i < _len; dim = ++_i) {
        n = vec[dim];
        if (n < this.ll[dim]) {
          v = this.ll[dim];
          dsq += (v - n) * (v - n);
          is_contained = false;
        } else if (n > this.ur[dim]) {
          v = this.ur[dim];
          nearest.push(v);
          dsq += (v - n) * (v - n);
          is_contained = false;
        } else {
          nearest.push(n);
        }
      }
      distance = Math.sqrt(dsq);
      return {
        distance: distance,
        nearest: nearest,
        is_contained: is_contained
      };
    };

    BoundingBox.prototype.split = function(axis, median) {
      var left, right;
      left = this.copy();
      right = this.copy();
      left.ur[axis] = median;
      right.ll[axis] = median;
      return {
        left: left,
        right: right
      };
    };

    BoundingBox.prototype.copy = function() {
      var bb, x;
      return bb = new BoundingBox((function() {
        var _i, _len, _ref, _results;
        _ref = this.ll;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          _results.push(x);
        }
        return _results;
      }).call(this), (function() {
        var _i, _len, _ref, _results;
        _ref = this.ur;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          x = _ref[_i];
          _results.push(x);
        }
        return _results;
      }).call(this));
    };

    return BoundingBox;

  })();

  exports.BoundingBox = BoundingBox;

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var Utils;



  Utils = {
    median: function(vals) {
      var m, res;
      vals.sort(function(a, b) {
        return a - b;
      });
      if (vals.length % 2) {
        res = vals[(vals.length - 1) / 2];
      } else {
        m = vals.length / 2;
        res = (vals[m] + vals[m - 1]) / 2;
      }
      return res;
    },
    is_power_of_two: function(x) {
      return x > 0 && !(x & (x - 1));
    },
    dist_sq: function(v1, v2) {
      var a, d, dsq, i, _i, _len;
      dsq = 0;
      for (i = _i = 0, _len = v1.length; _i < _len; i = ++_i) {
        a = v1[i];
        d = v2[i] - a;
        dsq += d * d;
      }
      return dsq;
    },
    dist: function(v1, v2) {
      return Math.sqrt(Utils.dist_sq(v1, v2));
    },
    point_segment_dist: function(v, s) {
      var d1, d2, diff, i, l2, proj, s_len, t, x;
      l2 = Utils.dist_sq(s[0], s[1]);
      s_len = Math.sqrt(l2);
      if (l2 === 0) {
        return {
          dist: Utils.dist(v, s[0]),
          point: (function() {
            var _i, _len, _ref, _results;
            _ref = s[0];
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              x = _ref[_i];
              _results.push(x);
            }
            return _results;
          })(),
          position_on_segment: [0, 0]
        };
      } else {
        d1 = Utils.diff(v, s[0]);
        d2 = Utils.diff(s[1], s[0]);
        t = Utils.dot_product(d1, d2) / l2;
        if (t < 0) {
          return {
            dist: Utils.dist(v, s[0]),
            point: (function() {
              var _i, _len, _ref, _results;
              _ref = s[0];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                _results.push(x);
              }
              return _results;
            })(),
            position_on_segment: [0, s_len]
          };
        } else if (t > 1) {
          return {
            dist: Utils.dist(v, s[1]),
            point: (function() {
              var _i, _len, _ref, _results;
              _ref = s[1];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                _results.push(x);
              }
              return _results;
            })(),
            position_on_segment: [s_len, 0]
          };
        } else {
          diff = Utils.diff(s[1], s[0]);
          diff = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = diff.length; _i < _len; _i++) {
              x = diff[_i];
              _results.push(t * x);
            }
            return _results;
          })();
          proj = (function() {
            var _i, _len, _ref, _results;
            _ref = s[0];
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              x = _ref[i];
              _results.push(x + diff[i]);
            }
            return _results;
          })();
          return {
            dist: Utils.dist(v, proj),
            point: proj,
            position_on_segment: [t * s_len, (1 - t) * s_len]
          };
        }
      }
    },
    diff: function(v1, v2) {
      var i, x, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = v1.length; _i < _len; i = ++_i) {
        x = v1[i];
        _results.push(x - v2[i]);
      }
      return _results;
    },
    dot_product: function(v1, v2) {
      var i, sum, x, _i, _len;
      sum = 0;
      for (i = _i = 0, _len = v1.length; _i < _len; i = ++_i) {
        x = v1[i];
        sum += x * v2[i];
      }
      return sum;
    }
  };

  exports.Utils = Utils;

}).call(this);

},{}]},{},[])
;